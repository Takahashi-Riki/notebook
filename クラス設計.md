# クラス

- 下記を構成要素としていればOK。
  - インスタンス変数
  - インスタンス変数を不正状態から防御し、正常に動作するメソッド

# インスタンス変数

- コンストラクタで確実に正常値を設定していればOK。
- 不変になっていればOK。

# メソッド

## what -何をやるか-

- 現実の営みとしてあり得るメソッドが定義されていればOK。

## where -どこでやるか-

### どのクラスに定義するか？

- ロジックが定義されているのはデータ保持側になっていればOK。
  - これができていれば出力引数を避けているはず。

### クラスのどこに定義するか？

- クラスメソッドを利用していて、下記に当てはまったらNG。
  - データとロジックの分離が発生してしまっている。
  - インスタンスメソッドに変更可能そう。
- 凝集度に無関係なものをクラスメソッドが良いOK。

### 初期化ロジックの一元化

- 初期化ロジックが分散しすぎる場合に、privateコンストラクタとファクトリメソッドで目的別初期化を行っていればOK。
※rubyだとprivateコンストラクタの実現は難しい
- ファクトリメソッドが増えすぎた場合に、ファクトリクラスを利用していればOK。

### 共通処理化

- ユースケースに広く横断する事柄であれば共通処理化してOK。
  - ログ出力
  - エラー検出
  - デバッグ
  - 例外処理
  - キャッシュ
  - 同期処理
  - 分散処理

## how -どんなロジックにするか-

### 全般（I/F + 内部ロジック）

- プリミティブ側ではなく独自の型を利用していればOK。（値の渡し間違いを型で防止する意図）

### I/F

- 引数が多くなりすぎた場合に、意味ある単位ごとにクラス化し、引数ではなくインスタンス変数として表現していればOK。

### 内部ロジック

- 不要な副作用を避けていればOK。※下記を満たせていれば防げるはず
  - データ(=状態)を引数で受け取る
  - 状態を変更しない
  - 値は関数の戻り値として返す
- 可変インスタンスを使い回していなければOK。
- ファイルやDBの読み書きが局所化されていればOK。
- 「尋ねるな命じろ」を守れていればOK。
- 

> 主作用：メソッドが引数を受け取り、値を返すこと。
> 
> 副作用：主作用以外に、下記のような状態変更をすること。
> - インスタンス変数の変更
> - グローバル変数の変更
> - 引数の変更
> - ファイルの読み書きなどのI/O操作

#### 条件分岐

- 早期returnを利用できていればOK。
- 同じ条件式の条件分岐を一箇所にまとめられていればOK。
- [interface を意識した実装](/クラス設計/Ruby で interface の概念をどう活用するか.md)ができていればOK。

