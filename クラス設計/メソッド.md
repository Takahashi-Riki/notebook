# 確認すべきこと

## ロジック設計

- 現実の営みとしてあり得るメソッドが定義されていればOK。

## ロジックの定義場所

- ロジックが定義されているのはデータ保持側になっていればOK。

<details><summary>サンプルコード</summary>

```ruby
class Money
  # 計算ロジックをデータ保持側に寄せる。
  def add(other)
    
  end
end
```
</details>

## I/F

### インスタンスの変更

- インスタンスを変更したい場合は、新しいインスタンスを作成していればOK。

<details><summary>サンプルコード</summary>

```ruby
class Money
  def add(other)
    # 省略

    added_amount = amount + other.amount
    # 変更したい場合は新しいインスタンスを作成する。
    Money.new(added_amount, currency)
  end
end
```
</details>

### 型

- プリミティブ側ではなく独自の型を利用していればOK。（値の渡し間違いを型で防止する意図）

<details><summary>サンプルコード</summary>

```ruby
class Money
  # 計算ロジックをデータ保持側に寄せる。
  def add(other)
    # 値の渡し間違いを型で防止する。
    raise TypeError.new("引数がお金ではありません") unless other.instance_of?(Money)
    raise ArgumentError.new("通貨単位が異なります") unless currency == other.currency

    # 省略
  end
end
```
</details>

## 内部ロジック

### ローカル変数

- 再代入/破壊的代入を避けていればOK。

<details><summary>サンプルコード</summary>

```ruby
# 再代入/破壊的代入は行わない。
def damage()
  basic_attack_power = ( member.power + member.weapon_attack ).floor
  final_attack_power = ( basic_attack_power * ( 1.0 + member.speed / 100.0 ) ).floor
  reduction = ( enemy.defence / 2 ).floor
  damage = [0, final_attack_power - reduction].max
  damage
end
```
</details>

- 可変インスタンスを使い回していなければOK。

<details><summary>サンプルコード</summary>

```ruby
# 可変インスタンスを使いまわさない。
attack_power_a = AttackPower.new(20)
attack_power_b = AttackPower.new(20)

weapon_a = Weapon.new(attack_power_a)
weapon_b = Weapon.new(attack_power_b)

weapon_a.attack_power_a.value += 5
```
</details>

### 副作用

- 特別な理由を除いて、副作用を防げていればOK。
  - データ(=状態)を引数で受け取る
  - 状態を変更しない
  - 値は関数の戻り値として返す

<details><summary>サンプルコード</summary>

```ruby
# クラスに副作用を与えるメソッドは保守が大変になることを理解し、避ける。
class AttackPower
  attr_accessor :value

  MIN = 0.freeze
  private_constant :MIN

  def initialize(value)
    raise ArgumentError if value < MIN
    @value = value
  end

  # a.データ(=状態)を引数で受け取る
  def reinforce(increment)
    raise TypeError unless increment.instance_of?(AttackPower)

    # b.状態を変更しない
    # c.値は関数の戻り値として返す
    AttackPower.new(value + increment.value)
  end

  def disable
    AttackPower.new(MIN)
  end
end

attack_power = AttackPower.new(20)
reinforced_attack_power = attack_power.reinforce(AttackPower.new(15))
disabled_attack_power = attack_power.disable

puts "reinforced attack power : #{reinforced_attack_power.value}"
# => reinforced attack power : 35

puts "disabled attack power   : #{  disabled_attack_power.value}"
# => disabled attack power   : 0
```
</details>

- ファイルやDBの読み書きが局所化されていればOK。
